(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{273:function(e,t,a){"use strict";a.r(t);var n=a(13),s=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"architectural-overview"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#architectural-overview"}},[e._v("#")]),e._v(" Architectural Overview")]),e._v(" "),t("h2",{attrs:{id:"_1-based-on-canvas"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-based-on-canvas"}},[e._v("#")]),e._v(" 1. Based on canvas")]),e._v(" "),t("p",[e._v("The underlying of CanvasUI relies on the HTML <canvas> element, which continuously clears/draws the canvas at a frequency of 60FPS (using requestAnimationFrame). The drawing process, at this level, can be seen as various drawLine / drawRect / fillColor and other operations.")]),e._v(" "),t("h2",{attrs:{id:"_2-object-oriented-abstraction"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-object-oriented-abstraction"}},[e._v("#")]),e._v(" 2. Object Oriented abstraction")]),e._v(" "),t("p",[e._v("Next, CanvasUI abstracts the tedious drawing process and wraps it in various component objects (for example: ButtonComponent / InputComponent / ImageComponent, etc.), each object has its own box model, its own drawing method, and its own event.")]),e._v(" "),t("h2",{attrs:{id:"_3-layout"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-layout"}},[e._v("#")]),e._v(" 3. Layout")]),e._v(" "),t("p",[e._v("After having the box model of each component, CanvasUI implements a complex layout engine to calculate the specific position of each component on the page, supporting Flex layout.")]),e._v(" "),t("h2",{attrs:{id:"_4-declarative-syntax"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-declarative-syntax"}},[e._v("#")]),e._v(" 4. Declarative syntax")]),e._v(" "),t("p",[e._v("CanvasUI implements an XML Parser using a finite state machine, so that the user interface can be written using a simple declarative syntax, and the tags will be compiled into a component tree through Tokenization and Tree Construction.")]),e._v(" "),t("h2",{attrs:{id:"_5-mvvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-mvvm"}},[e._v("#")]),e._v(" 5. MVVM")]),e._v(" "),t("p",[e._v("CanvasUI implements MVVM based on Proxy, and collects the corresponding dependencies in the getter. When the data changes and triggers the setter, the view will be automatically updated. The two-way binding of data can be achieved only through simple template syntax.")])])}),[],!1,null,null,null);t.default=s.exports}}]);